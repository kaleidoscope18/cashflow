package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"cashflow/api/graph/generated"
	"cashflow/models"
	"cashflow/utils"
	"context"
	"fmt"
	"strings"
	"time"
)

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input generated.NewTransaction) (string, error) {
	description := validateDescription(input.Description)
	recurrency, err := validateRecurrency(input.Recurrency)
	if err != nil {
		return "", err
	}

	return (*r.TransactionService).WriteTransaction(input.Date, input.Amount, description, recurrency)
}

// CreateTransactions is the resolver for the createTransactions field.
func (r *mutationResolver) CreateTransactions(ctx context.Context, input []*generated.NewTransaction) ([]string, error) {
	results := make([]string, 0)
	errors := make([]string, 0)

	for i, transaction := range input {
		t, err := r.CreateTransaction(ctx, *transaction)
		if err == nil {
			results = append(results, t)
		} else {
			errors = append(errors, fmt.Sprintf("#%d on date %s with amount %.2f, error: %s", i, transaction.Date, transaction.Amount, err.Error()))
		}
	}

	var err error
	if len(errors) != 0 {
		err = fmt.Errorf("transactions that were created: %s - transactions not created: %s",
			strings.Join(results, ","),
			strings.Join(errors, ","),
		)
	}

	return results, err
}

// DeleteTransaction is the resolver for the deleteTransaction field.
func (r *mutationResolver) DeleteTransaction(ctx context.Context, id string) (string, error) {
	return (*r.TransactionService).DeleteTransaction(ctx, id)
}

// DeleteTransactions is the resolver for the deleteTransactions field.
func (r *mutationResolver) DeleteTransactions(ctx context.Context, ids []string) ([]string, error) {
	results := make([]string, 0)
	errors := make([]string, 0)

	for _, id := range ids {
		deletedId, err := r.DeleteTransaction(ctx, id)
		if err == nil {
			results = append(results, deletedId)
		} else {
			errors = append(errors, id)
		}
	}

	var err error
	if len(errors) != 0 {
		err = fmt.Errorf("transactions that were deleted: %s - transactions not found: %s",
			strings.Join(results, ","),
			strings.Join(errors, ","),
		)
	}

	return results, err
}

// EditRecurringTransaction is the resolver for the editRecurringTransaction field.
func (r *mutationResolver) EditRecurringTransaction(ctx context.Context, input generated.RecurringTransactionEditInput) (string, error) {
	_, err := validateRecurrency(input.Recurrency)
	if err != nil {
		return "", err
	}

	return (*r.TransactionService).EditRecurringTransaction(ctx, input.Type, models.TransactionEdit{
		Id:          input.ID,
		Date:        validateDate(input.Date),
		Description: input.Description,
		Recurrency:  input.Recurrency,
		Amount:      input.Amount,
	})
}

// ListTransactions is the resolver for the listTransactions field.
func (r *queryResolver) ListTransactions(ctx context.Context, from *time.Time, to *time.Time) ([]*models.ComputedTransaction, error) {
	if from == nil || to == nil {
		err := fmt.Errorf("please provide from and to dates")
		return nil, err
	}

	result, err := (*r.TransactionService).ListTransactions(ctx, *from, *to)
	if err != nil {
		return nil, err
	}

	return utils.ConvertStructToPointersArray(result), nil
}
